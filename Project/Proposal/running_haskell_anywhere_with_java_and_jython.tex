%\documentclass[twocolumn]{article}
\documentclass{report}

\usepackage{url}
\usepackage{indentfirst}
\usepackage{float}
\usepackage{listings} % Include the listings-package
\usepackage{mdframed}
\usepackage[numbers,sort]{natbib}

\title{HamSkill: Run Haskell Anywhere with Scala\\[1in]
	   CS252 Project Proposal}

\author{
  Zayd Hammoudeh \\
  (zayd.hammoudeh@sjsu.edu)
  }
\date{}


% Skip lines after each paragraph.
\setlength\parskip{\baselineskip}

\begin{document}
\maketitle

\renewcommand\thesection{\arabic{section}}
\section{Running in the Java Virtual Machine}

C is one of the most commonly used languages when the goal is maximum performance.  However, C/C++'s "write once, compile anywhere" paradigm limits its portability.  In contrast, the near ubiquity of the Java Virtual Machine (JVM) allows it to be "write once, run anywhere."  

On many occasions, developers have leveraged the JVM's "run anywhere" capability in order to run allow other languages.  Examples include: JRuby for the Ruby programming language \cite{jruby}, Jython for the Python programming language \cite{jython_jvm}, Renjin for the R programming language \cite{renjin}, and Scala \cite{scala}.

Currently, there is no full implementation of Haskell in the JVM.  One Haskell dialect that is runnable in Java is Frege \cite{frege}.  

In this project, I will implement, \emph{HamSkill}, a dialect of Haskell that is runnable in the Java Virtual Machine.

\section{Implementation Proposal}

This section outlines the overall implementation plan for this project.  It is divided into subsections based on the overall themes and ideas.  

\subsection{Parser}

When parsing structured text like software code, one of the key aspects of the overall system is picking a scalable, flexible, and easily expandable parser.  For this project, I am using ANTLR (\underline{AN}other \underline{T}ool for \underline{L}anguage \underline{R}ecognition)

ANTLR grammars do exist for Haskell; an example is \cite{antlrHaskellLexer}.  However, as a learning experience and to ensure maximum flexibility, I plan to write my own grammar as well as the accompanying base listener (in Java).  

\subsection{JVM-Supported Programming Language}

When selecting the implementation language, my criteria were: runnable in Java, and maximum similarity to Haskell.  I initially considered Python (via Jython) due to its higher order function support and concise style.  

In the end, I settled on using Scala for this project due to its syntax being more alignable to that of Haskell; an example of this is Scala's support for a function based pattern matching style.  What is more, critical aspects of Haskell (e.g. lazy evaluation, immutability of objects, etc.) has parallels in Scala.  One major disadvantage of this decisions is that Scala has a much weaker type inference system than does Haskell or Python.  An example of this is described in section \ref{partiallyAppliedFunctions}.  

While it is my expectation that a fuller implementation of Haskell may be more achievable in Python, it would require substantially more effort to implement the functional programming aspects of Haskell that Scala comes with out of the box.  In the end, when doing a programming language conversion, it is exceptionally unlikely that the destination language will perfectly support all aspects of the source language.  As such, some degree of compromise is required which is why Hamskill is only a dialect of Haskell and not the real thing.

\subsection{Supported Types}

\emph{HamSkill} will only support a select subset of Haskell's available types.  The list of planned types are: {\tt Bool}, {\tt Integer} (i.e. bounded), {\tt Char}, and {\tt List} (currently only finite lists are planned, but that may change depending on the speed and complexity of the implementation).

While implementing floating point numbers would not add substantial complexity at a basic level, ensuring that the floating point behavior of \emph{HamSkill} (i.e. Scala) and Haskell are identical is beyond the scope of this project.

\subsection{Nested Function Calls}

Imperative languages (e.g. Java) are generally more verbose than functional languages; Haskell is no exception to this.  Such conciseness introduces significant challenges when writing a parser as the contextual clues become less obvious.  For example, \ref{fig:addTwoNumbersHaskell} is a simple line of Haskell code that prints to the screen the result of a function {\tt addTwoNumbs} that takes two integers {\tt x} and {\tt y}. 

\begin{figure}[H]\label{fig:addTwoNumbersHaskell}
\begin{mdframed}
\begin{lstlisting}[language=Haskell]
putStrLn $ show $ addTwoNumbs x y
\end{lstlisting}
\end{mdframed}
\caption{Simple Function Call in \bf{Haskell}}
\end{figure}

Similar code in Java is shown in figure \ref{fig:addTwoNumbersJava}

\begin{figure}[H]\label{fig:addTwoNumbersJava}
\begin{mdframed}
\begin{lstlisting}[language=Java]
System.out.println( addTwoNumbs(x, y) ) ;
\end{lstlisting}
\end{mdframed}
\caption{Simple Function Call in \bf{Java}}
\end{figure}

In the Java syntax, it is much clearer that {\tt addTwoInts} is a function since the parameters are inside parentheses and comma separated.  To simplify the parsing for this in Haskell, the Hamskill dialect will require function arguments to be succeeded by double parentheses ``{\tt ((}" and ``{\tt ))}".  Figure \ref{fig:addTwoNumbersHamskill} shows the Hamskill version of the Haskell code in figure \ref{fig:addTwoNumbersHaskell}.

\begin{figure}[H]\label{fig:addTwoNumbersHamskill}
\begin{mdframed}
\begin{lstlisting}[language=Haskell]
putStrLn $ show $ addTwoInts ((x y))
\end{lstlisting}
\end{mdframed}
\caption{Simple Function Call in \bf{Hamskill}}
\end{figure}

\subsection{Defining Scope and Scala Object Name via {\tt module}}

A program in Haskell is composed of a set of "{\tt module}" files.  {\tt module} serves the role of defining the scope of a function (e.g. public or private) as well as for defining an abstract data type \cite{haskellModule}.  In Hamskill, I will use the Haskell module to define whether the Scala methods are private (since by default functions are public) as well as the name of the Scala object.

\subsection{Partially Applied Functions}\label{partiallyAppliedFunctions}

Haskell supports partially applied functions.  Figure \ref{fig:addFiveHaskell} shows the {\tt addTwoInts} method with a single argument (i.e. "{\tt 5}") being stored in a variable "{\tt addFive}".  

\begin{figure}[H]\label{fig:addFiveHaskell}
\begin{mdframed}
\begin{lstlisting}[language=Haskell]
let addFive = addTwoInts 5
\end{lstlisting}
\end{mdframed}
\caption{Partially Applied addTwoInts Function in \bf{Haskell}}
\end{figure}

Partially applied functions in Scala has advantages and disadvantages in comparison to Haskell.  One of these disadvantages is evident when figures \ref{fig:addFiveHaskell} and \ref{fig:addFiveScala} are compared.  Note that the Scala function requires an underscore ("\_") for each missing argument as well as the type for that argument.  This makes converting Haskell code to Scala problematic as the function prototype must be fixed and known at conversion time.  

\begin{figure}[H]\label{fig:addFiveScala}
\begin{mdframed}
\begin{lstlisting}[language=Scala]
val addFive = addTwoInts(5, _: Int)
\end{lstlisting}
\end{mdframed}
\caption{Partially Applied addTwoInts Function in \bf{Scala}}
\end{figure}

To simplify this, Hamskill will require that any partially defined functions are either declared in the same file/module.  I will investigate using a predefined list of functions, but this may not be feasible or support will be very limited due to the requirement to define the parameter type.

\subsection{Higher Order Support}

Scala and Haskell are both functional programming languages; one important consequence of this is that both support higher order functions.  Hamskill will support functions as input parameters to functions.  If time allows, I will also investigate the ability to return functions from functions.  The extent to which this is supported will be dependent on the extent to which partially applied functions are supported as defined in section \ref{partiallyAppliedFunctions}.

\subsection{Lambda to Anonymous Functions}

There is significant similarity between a Lamda function in Haskell and an anonymous function in Scala.  One primary difference is that Scala requires the developer to specify the types of the parameters in the anonymous function while Scala does not.  

\section{Tentative Schedule}

If you are satisfied with this plan, I will draft a schedule.  I did not want to put too much thought into this until I got your buyoff on the plan as a whole.

\pagebreak
\bibliographystyle{plainurl}
\bibliography{proposal_biblio}

\end{document}
