\documentclass{article}

\usepackage{fullpage}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
%\usepackagen{url}
\usepackage{float}
\usepackage{paralist}
\usepackage{indentfirst}

\floatstyle{boxed}
\restylefloat{figure}



\newcommand{\rel}[1]{ \mbox{\sc [#1]} }
% Commands for formatting figure
\newcommand{\mydefhead}[2]{\multicolumn{2}{l}{{#1}}&\mbox{\emph{#2}}\\}
\newcommand{\mydefcase}[2]{\qquad\qquad& #1 &\mbox{#2}\\}

% Commands for language format
\newcommand{\assign}[2]{#1~{:=}~#2}
\newcommand{\ife}[3]{\mbox{\tt if}~{#1}~\mbox{\tt then}~{#2}~\mbox{\tt else}~{#3}}
\newcommand{\whilee}[2]{\mbox{\tt while}~(#1)~#2}
\newcommand{\note}[1]{\mbox{\tt not}~#1}
\newcommand{\ande}[2]{\mbox{\tt and}~(#1)~(#2)}
\newcommand{\ore}[2]{\mbox{\tt or}~(#1)~(#2)}
\newcommand{\true}{\mbox{\tt true}}
\newcommand{\false}{\mbox{\tt false}}

\title{Homework 2: Operational Semantics for the WHILE Language}

\author{
  Zayd Hammoudeh \\
  (zayd.hammoudeh@sjsu.edu)
  }
\date{}

\setlength\parskip{\baselineskip}

\begin{document}
\maketitle

\section{Introduction to the WHILE Language}

The "WHILE" language is a basic language that was defined in class.  Figure \ref{fig:lang} defines the expressions, values, and operators in this language.  This notation for expressions ($e$), values ($v$), variables/addresses ($x$), and store ($\sigma$) applies to all sections of this document.

\newcommand{\ssrule}[3]{
  \rel{#1} &
  \frac{\strut\begin{array}{@{}c@{}} #2 \end{array}}
       {\strut\begin{array}{@{}c@{}} #3 \end{array}}
   \\~\\
}
\newcommand{\sstep}[4]{{#1},{#2} \rightarrow {#3},{#4}}
\newcommand{\sstepraw}[4]{{#1},{#2} \rightarrow {#3},{#4}}
\begin{figure}[H]\label{fig:lang}
\caption{The WHILE language}
\[
\begin{array}{llr}
  \mydefhead{e ::=\qquad\qquad\qquad\qquad}{Expressions}
  \mydefcase{x}{variables/addresses}
  \mydefcase{v}{values}
  \mydefcase{\assign x e}{assignment}
  \mydefcase{e; e}{sequential expressions}
  \mydefcase{e ~op~ e}{binary operations}
  \mydefcase{\ife e e e}{conditional expressions}
  \mydefcase{\whilee e e}{while expressions}
  \mydefcase{\note e}{not expressions}
  \mydefcase{\ande e e}{and expressions ({\bf Are the parentheses ok?})}
  \mydefcase{\ore e e}{or expressions ({\bf Are the parentheses ok?})}
  \\
  \mydefhead{v ::=\qquad\qquad\qquad\qquad}{Values}
  \mydefcase{i}{integer values}
  \mydefcase{b}{boolean values}
  \\
  op ::= & + ~|~ - ~|~ * ~|~ / ~|~ > ~|~ >= ~|~ < ~|~ <=  & \mbox{\emph{Binary operators}} 
  \\
  \\
  \mydefhead{\sigma}{Store} 
\end{array}
\]
\end{figure}


%---------
\section{Base WHILE Language Small-Step Semantics Rules}


The following figures enumerate the execution order, small-step semantics rules for the WHILE language expressions as defined in class.  

\iffalse
\begin{figure}[H]\label{fig:smallstep}
\caption{Small-step semantics for WHILE}
{\bf Runtime Syntax:}
\[
\begin{array}{rclcl}
  \sigma & \in & {Store} \quad  & = & \quad {variable} ~\rightarrow ~v \\
  \\
\end{array}
\]
{\bf Evaluation Rules:~~~ \fbox{$\sstepraw{e}{\sigma}{e'}{\sigma'}$}} \\
\[
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-var}{
  x \in domain(\sigma) \qquad \sigma(x)=v
}{
  \sstep{x}{\sigma}{v}{\sigma}
}
\ssrule{ss-assign}{
}{
  \sstep{\assign{x}{v}}{\sigma}{v}{\sigma[x:=v]}
}
\ssrule{ss-op}{
  v = v_1 ~op~ v_2
}{
  \sstep{v_1~op~v_2}{\sigma}{v}{\sigma}
}
\ssrule{ss-seq}{
}{
  \sstep{v;e}{\sigma}{e}{\sigma}
}
\ssrule{ss-iftrue}{
}{
  \sstep{\ife{\true}{e_1}{e_2}}{\sigma}{e_1}{\sigma}
}
\ssrule{ss-iffalse}{
}{
  \sstep{\ife{\false}{e_1}{e_2}}{\sigma}{e_2}{\sigma}
}
\ssrule{ss-while}{
}{
  \sstep{\whilee{e_1}{e_2}}{\sigma}{\ife{e_1}{e_2;\whilee{e_1}{e_2}}{\false}}{\sigma}
}
\end{array}
\]
\end{figure}
\fi

\begin{figure}[H]\label{fig:varRules}
\caption{Variable Small-Step Semantics Evaluation Order Rule}
{\bf Variable Evaluation Rule:}
\[
\\
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-var}{
  x \in domain(\sigma) \qquad \sigma(x)=v
}{
  \sstep{x}{\sigma}{v}{\sigma}
}
\end{array}
\]
\end{figure}

\begin{figure}[H]\label{fig:assignRules}
\caption{Set/Assignment Small-Step Semantics Evaluation Order Rules}
{\bf Set/Assignment Evaluation Rules:} 
\[
\\
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-assignContext}{
  \sstep{e}{\sigma}{e'}{\sigma'}
}{
  \sstep{\assign{x}{e}}{\sigma}{\assign{x}{e'}}{\sigma'}
}
\ssrule{ss-assignReduction}{
}{
  \sstep{\assign{x}{v}}{\sigma}{v}{\sigma[x:=v]}
}
\end{array}
\]
\end{figure}


\begin{figure}[H]\label{fig:opRules}
\caption{Binary Operator ({\tt op}) Evaluation Order Rules}
{\bf Binary Operator ({\tt op}) Evaluation Rules:}
\[
\\
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-opContext1}{
  \sstep{e_1}{\sigma}{e_1'}{\sigma'}
}{
  \sstep{e_1~op~e_2}{\sigma}{e_1'~op~e_2}{\sigma'}
}
\ssrule{ss-opContext2}{
  \sstep{e}{\sigma}{e'}{\sigma'}
}{
  \sstep{v~op~e}{\sigma}{v~op~e'}{\sigma'}
}
\end{array}
\]
{\bf Is there a reason you used the infix op notation here instead of the notation from class "$\tt v_3 = apply(op, v_1, v_2)$"}
\[
\\
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-opReduction}{
  v_3 = v_1 ~op~ v_2
}{
  \sstep{v_1~op~v_2}{\sigma}{v_3}{\sigma}
}
\end{array}
\]
\end{figure}

\begin{figure}[H]\label{fig:seqRules}
\caption{Sequence ({\tt ;}) Evaluation Order Rules}
{\bf Sequence ({\tt ;}) Evaluation Rules:}
\[
\\
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-seqContext}{
  \sstep{e_1}{\sigma}{e_1'}{\sigma'}
}{
  \sstep{e_1 ; e_2}{\sigma}{e_1' ; e_2}{\sigma'}
}
\ssrule{ss-seqReduction}{
}{
  \sstep{v ; e}{\sigma}{e}{\sigma}
}
\end{array}
\]
\end{figure}

\begin{figure}[H]\label{fig:condRules}
\caption{Conditional ({\tt if}) Small-Step Semantics Evaluation Order Rules}
{\bf Conditional Statement ({\tt if}) Evaluation Rules:}
\[
\\
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-ifContext}{
  \sstep{e_1}{\sigma}{e_1'}{\sigma'}
}{
  \sstep{\ife{e_1}{e_2}{e_3}}{\sigma}{\ife{e_1'}{e_2}{e_3}}{\sigma'}
}
\ssrule{ss-ifTrueReduction}{
}{
  \sstep{\ife{\true}{e_1}{e_2}}{\sigma}{e_1}{\sigma}
}
\ssrule{ss-ifFalseReduction}{
}{
  \sstep{\ife{\false}{e_1}{e_2}}{\sigma}{e_2}{\sigma}
}
\end{array}
\]
\end{figure}

\begin{figure}[H]\label{fig:whileRules}
\caption{{\tt while} Small-Step Semantics Evaluation Order Rule}
{\bf {\tt while} Evaluation Rule:} 
\[
\\
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-whileReduction}{
}{
  \sstep{\whilee{e_1}{e_2}}{\sigma}{\ife{e_1}{e_2;\whilee{e_1}{e_2}}{\false}}{\sigma}
}
\end{array}
\]
\end{figure}

%---------
\section{Boolean Expressions Small-Step Semantics Rules}


In this section, I add three new expression types to the WHILE language namely: {\tt not}, {\tt and}, and {\tt or}.  The evaluation order rules for each are below.


\bf Can I have the parentheses in the "{\tt and}" and "{\tt or}" statements?  Is an infix style more typically used?

\begin{figure}[H]\label{fig:notRules}
\caption{{\tt not} Small-Step Semantics Evaluation Order Rules}
{\bf {\tt not} Evaluation Rules:} 
\[
\\
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-notContext}{
  \sstep{e}{\sigma}{e'}{\sigma'}
}{
  \sstep{\note{e}}{\sigma}{\note{e'}}{\sigma'}
}
\end{array}
\]
{\bf Not sure if I need this.  If I do, then why?  Why is this not like the  "{\tt op}" case?  Can this be used to enforce that the value types are boolean?} 
\[
\\
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-notReduction}{
}{
  \sstep{\note{v}}{\sigma}{\ife{v}{\false}{\true}}{\sigma}
}
\end{array}
\]
{\bf I believe the above rule makes these unnecessary.  Would most define as above or like below (assuming they are even necessary)?} 
\[
\\
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-notTrue}{
}{
  \sstep{\note{\true}}{\sigma}{\false}{\sigma}
}
\ssrule{ss-notFalse}{
}{
  \sstep{\note{\false}}{\sigma}{\true}{\sigma}
}
\end{array}
\]
\end{figure}

\begin{figure}[H]\label{fig:andRules}
\caption{{\tt and} Small-Step Semantics Evaluation Order Rules}
{\bf {\tt and} Evaluation Rules: (In the case of rule "SS-ANDREDUCTION", "$e$" could return an integer.  I do not enforce any typing here while I do in the lower set of rules.  Is that ok?  Rather than just making it "$e$", I could make it "${\tt AND~e~True}$")}
\[
\\
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-andContext}{
  \sstep{e_1}{\sigma}{e_1'}{\sigma'}
}{
  \sstep{\ande{e_1}{e_2}}{\sigma}{\ande{e_1'}{e_2}}{\sigma'}
}
\ssrule{ss-andReduction}{
}{
  \sstep{\ande{v}{e}}{\sigma}{\ife{v}{e}{\false}}{\sigma}
}
\end{array}
\]
{\bf Using the above, I think I do not need these.  However, I believe the implementation
from an execution perspective of these is slightly different since the above case is short circuit compare (which could affect the store) while the lower case is not.  Correct me if I am wrong.} 
\[
\\
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-andContext2}{
  \sstep{e}{\sigma}{e'}{\sigma'}
}{
  \sstep{\ande{v}{e}}{\sigma}{\ande{v}{e'}}{\sigma'}
}
\ssrule{ss-andAllTrue}{
}{
  \sstep{\ande{\true}{\true}}{\sigma}{\true}{\sigma}
}
\ssrule{ss-andFalse1}{
}{
  \sstep{\ande{\false}{v}}{\sigma}{\false}{\sigma}
}
\ssrule{ss-andFalse2}{
}{
  \sstep{\ande{v}{\false}}{\sigma}{\false}{\sigma}
}
\end{array}
\]
\end{figure}

\begin{figure}[H]\label{fig:orRules}
\caption{{\tt or} Small-Step Semantics Evaluation Order Rule}
{\bf {\tt or} Evaluation Rule: (Is defining "temporary variables" as I did allowed in small step semantics?  I assumed it was because of how you handled the "{\tt op}" expression.  I also assumed that defining these temp variables is required since they enforce the evaluation order (correct me if I am wrong).} 
\[
\\
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-orReduction}{
  e_1'=\note{e_1} \qquad e_2'=\note{e_2} \qquad e_3=\ande{e_1'}{e_2'}
}{
  \sstep{\ore{e_1}{e_2}}{\sigma}{\note{e_3}}{\sigma}
}
\end{array}
\]
\end{figure}

\end{document}

