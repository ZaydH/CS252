import java.util.Stack;

public class HaskellTokensToScala extends HaskellBaseListener {

    private StringBuilder fileContents = new StringBuilder();
    private int nextParamNumber;
    private int BASE_PARAM_NUMBER = 0;
    private String scalaModuleName;
    private int indentLevel = 0;
    
    // Stacks are used when data may need to be stored across nesting.
    private Stack<Boolean> commaSeparateTerms = new Stack<Boolean>();
    private Stack<Boolean> firstCommaTerm = new Stack<Boolean>();
    private Stack<String> haskellFunctionToScalaMethodName = new Stack<String>();
    
    private boolean firstPatternMatchingArgument;
    
    /**
     * Base error message used for printing when something when wrong.
     */
    private final String baseErrorMessage = "Something went wrong here.  Did not expect this ";
    /**
     * Operator separating the "case" statement and any pattern matching parameters and
     * the expression.
     */
    private final String PATTERN_MATCHING_OPERATOR = " =>";
    /**
     * Used to represent a tab/indent.  Using spaces.
     */
    private final String TAB_STRING = "  ";
    /**
     * Statement used at the beginning of a pattern matching in Scala.  This is equivalent to the
     * reuse of the function name in Haskell.
     */
    private final String PATTERN_MATCHING_HEADER = "case";
    /**
     * Select type of call by parameter.  Right now using lazy parameters.
     */
    private String SCALAR_INPUT_PARAMETER_CALL_BY_TYPE = ": =>";
    /**
     * Used to invoke the pattern matching syntax.
     */
    private String SCALA_USE_HASKELL_PATTERN_MATCHING_STYLE = "match ";
    /**
     * Haskell Tokenized Analyzer's Constructor.
     * 
     * @param haskellModuleName Name of the Haskell module.  This will eventually become the Scala Object name
     */
    public HaskellTokensToScala(String haskellModuleName){
        
        // Save the specified Haskell name to use in the Scala file definition.
        scalaModuleName = haskellModuleName;
        
        // Set the indent level to zero.
        resetIndentLevel();
    }
    /**
     * Generates the Scala file header.
     * 
     * Also embeds all code inside a Scala object.
     * 
     * @param ctx ANTLR Context
     */
    @Override public void enterProgram(HaskellParser.ProgramContext ctx) { 
        
        // Add indent if any.
        printIndent();
        
        // Put a header at the top of the file.
        fileContents.append(  "/** Autogenerated Scala Code by ANTLR v4 parser.\n"
                            + "  * Original Develop: Zayd Hammoudeh (zayd.hammoudeh@sjsu.edu)\n"
                            + "  */\n\n");
        
        // Embed the code in a Scala object
        fileContents.append("object " + scalaModuleName + " {\n\n");
    }
    
    /**
     * Closes the scala file.
     * 
     * @param ctx ANTLR Context
     */
    @Override public void exitProgram(HaskellParser.ProgramContext ctx) { 
        
        // Decrement the indent and then display it.
        decrementIndentLevel(true);
        
        // Put a header at the top of the file.
        printIndent(); // Add indent if any.
        fileContents.append("}\n");
    }
    /** 
     * General handler that is called when any contiguous block of code (including a comment)
     * is invoked.
     */
    @Override public void enterCodeBlock(HaskellParser.CodeBlockContext ctx) { 
        // Increase the indent by one level then print it.
        incrementIndentLevel(false); 
     }
    /** 
     * General cleanup funciton when a code block is done.
     */
    @Override public void exitCodeBlock(HaskellParser.CodeBlockContext ctx) { 
        // Decrease the indent by one level
        decrementIndentLevel(false);
    }
    /**
     * Takes a line comment from Haskell and adds it to the Scala file.
     */
    @Override public void enterLineComment(HaskellParser.LineCommentContext ctx) { 
        // Increase the indent by one level then print it.
        printIndent();
        fileContents.append("//");
     }
    /**
     * Handles the close of a line comment.
     */
    @Override public void exitLineComment(HaskellParser.LineCommentContext ctx) { 
        // Increase the indent by one level then print it.
        printIndent();
        fileContents.append("\n");
     }
    @Override public void enterCommentWord(HaskellParser.CommentWordContext ctx) { 
        fileContents.append(" ");
        fileContents.append(ctx.getText());
    }
    /**
     * Entry to the Haskell function
     * 
     * @param ctx ANTLR Context
     */
    @Override public void enterFunc(HaskellParser.FuncContext ctx) { 
        // Puts the file header.
        printIndent();
        fileContents.append("def ");
        
        // Reset the parameter number
        resetNextParamNumber();
    }
    /**
     * Handles the end of the Haskell function.
     * 
     * @param ctx The ANTLR Context
     */
    @Override public void exitFunc(HaskellParser.FuncContext ctx) { 
        // Decrement the number of indents and then add it to the file.
        printIndent();
        fileContents.append(  "} // End of function\n\n");
    }
    /**
     * Entry to the Haskell function prototype
     * 
     * @param ctx ANTLR Context
     */
    @Override public void enterFuncPrototype(HaskellParser.FuncPrototypeContext ctx) { 
        // Puts the file name
        fileContents.append(ctx.functionName().getText());
    }
    /**
     * Closes the function prototype.
     * 
     * @param ctx ANTLR Context
     */
    @Override public void exitFuncPrototype(HaskellParser.FuncPrototypeContext ctx) { 
        fileContents.append("{\n");
    }
    /**
     * Handles the entrance to a Haskell function. 
     */
    @Override public void enterFuncbody(HaskellParser.FuncbodyContext ctx) { 
        // Increase the indent level.
        incrementIndentLevel(false);
        
    }
    /**
     * Handles the exit from a Haskell function. 
     */
    @Override public void exitFuncbody(HaskellParser.FuncbodyContext ctx) { 
        // Increase the indent level.
        decrementIndentLevel(false);
    }
    /**
     * Defines the Scala code when starting the type signature (i.e. input parameters)
     * for a Haskell function.
     * 
     * @param ctx The ANTLR Context
     */
    @Override public void enterTypeSignature(HaskellParser.TypeSignatureContext ctx) { 
        fileContents.append("(");
    }
    /**
     * At the end of a type signature, close the function definition
     * 
     * @param ctx The ANTLR Context
     */
    @Override public void exitTypeSignature(HaskellParser.TypeSignatureContext ctx) { 
        fileContents.append(  ") ");
    }
    /**
     * Performs the handling of the type in function prototype.
     */
    @Override public void enterInputType(HaskellParser.InputTypeContext ctx) { 
        if(!isFirstParameter()) fileContents.append(", ");
        
        // Add the parameter name and type.
        fileContents.append(getInputParameterName());
        fileContents.append(" ").append(SCALAR_INPUT_PARAMETER_CALL_BY_TYPE);
        fileContents.append(" ").append(convertHaskellTypeNameToScala(ctx.getText()));
    }
    /**
     * Performs any cleanup required at the end of a part.
     * 
     * @param ctx The ANTLR Context
     */
    @Override public void exitInputType(HaskellParser.InputTypeContext ctx) { 
        // Go to the next parameter ID
        incrementParameterId();
    }    
    /**
     * At the end of a type signature, close the function definition
     * 
     * @param ctx The ANTLR Context
     */
    @Override public void enterReturnType(HaskellParser.ReturnTypeContext ctx) {
        fileContents.append(": " + convertHaskellTypeNameToScala(ctx.getText()) + " = ");
        fileContents.append("(");
        
        // List all parameters for the function.
        for(int i = BASE_PARAM_NUMBER; i < nextParamNumber; i++){
            // Comma separate multiple arguments
            if(i != BASE_PARAM_NUMBER) fileContents.append(", ");
            
            // Put the parameter name
            fileContents.append(getInputParameterName(i));
        }
        fileContents.append(") ").append(SCALA_USE_HASKELL_PATTERN_MATCHING_STYLE);
    }
    /**
     * Handles the entry to a single function/pattern ing statement.
     */
    @Override public void enterFuncStatement(HaskellParser.FuncStatementContext ctx) {
        // Increment the indent and print them.
        incrementIndentLevel(true);
        fileContents.append(PATTERN_MATCHING_HEADER);
    }
    /**
     * Handles the exit to a single function/pattern matching statement.
     */
    @Override public void exitFuncStatement(HaskellParser.FuncStatementContext ctx) { 
        // Close the function statement
        fileContents.append("\n");
        decrementIndentLevel(false);
    }
    /**
     * End of a ALL pattern matching arguments.  This puts a pattern matching Scala symbol into the string.
     */
    @Override public void enterPatternMatchingArguments(HaskellParser.PatternMatchingArgumentsContext ctx) { 
        fileContents.append(" (");
        firstPatternMatchingArgument = true;
        
    }
    /**
     * End of a ALL pattern matching arguments.  This puts a pattern matching Scala symbol into the string.
     */
    @Override public void exitPatternMatchingArguments(HaskellParser.PatternMatchingArgumentsContext ctx) {         
        fileContents.append(")");
        fileContents.append(PATTERN_MATCHING_OPERATOR);
    }
    /**
     * Handles a single pattern matching argument.
     */
    @Override public void enterPatternMatchingArgument(HaskellParser.PatternMatchingArgumentContext ctx) { 
        // If not the first pattern matching argument, then comma separate.
        if(!firstPatternMatchingArgument)
            fileContents.append(", ");
        firstPatternMatchingArgument = false;
        // Print the parameter information.
        fileContents.append(ctx.getText());
    }
    /**
     * End of a pattern matching argument.  Currently a no-op
     */
    @Override public void exitPatternMatchingArgument(HaskellParser.PatternMatchingArgumentContext ctx) { }
    /**
     * Opens an expression. For robustness, everything is put in parentheses so this puts a left "(" 
     * parentheses at the beginning of the expression.
     */
    @Override public void enterPatternMatchingExpression(HaskellParser.PatternMatchingExpressionContext ctx) { 
        //fileContents.append(" ");
    }
    /**
     * Prints a pattern matching term.  Currently this does nothing.
     */
    @Override public void enterPatternMatchingTerm(HaskellParser.PatternMatchingTermContext ctx) { 
    }
    /**
     * Opens a parenthesis for the pattern matching term.
     */
    @Override public void enterPatternMatchParen(HaskellParser.PatternMatchParenContext ctx) { 
        fileContents.append(" (");
    }
    /**
     * Opens a parenthesis for the pattern matching term.
     */
    @Override public void exitPatternMatchParen(HaskellParser.PatternMatchParenContext ctx) { 
        fileContents.append(")");
    }
    /**
     * Opens a parenthesis for the pattern matching term.
     */
    @Override public void enterPatternMatchArray(HaskellParser.PatternMatchArrayContext ctx) { 
        fileContents.append("List(");
    }
    /**
     * Opens a parenthesis for the pattern matching term.
     */
    @Override public void exitPatternMatchArray(HaskellParser.PatternMatchArrayContext ctx) { 
        fileContents.append(")");
    }
    /**
     * Opens a parenthesis for the pattern matching term.
     */
    @Override public void enterGeneralPatternMatchingTerm(HaskellParser.GeneralPatternMatchingTermContext ctx) { 
    	
    	if(!commaSeparateTerms.isEmpty()){
    		// For the first term, just skip and do not put a comma,
    		if(firstCommaTerm.peek() == Boolean.TRUE){
    			firstCommaTerm.pop();
    			firstCommaTerm.push(Boolean.FALSE);
    		}
    		// For everything after the first term, 
    		else{
    			// For multiple terms, 
    			fileContents.append(",");
    		}    		
    	}
        fileContents.append(" ").append(ctx.getText());
    }
	/**
	 * Used for a function call inside a Haskell program.  Opens the call for scala.
	 */
	@Override public void enterGeneralFunctionCall(HaskellParser.GeneralFunctionCallContext ctx) { 
		fileContents.append("(");
		
		 commaSeparateTerms.push(Boolean.TRUE);
		 firstCommaTerm.push(Boolean.TRUE);
	}
	/**
	 * Used for a function call inside a Haskell Program.  Closes the call in Scala.
	 */
	@Override public void exitGeneralFunctionCall(HaskellParser.GeneralFunctionCallContext ctx) { 
		fileContents.append(")");
		// Clear any nested functions.
		commaSeparateTerms.pop();
		firstCommaTerm.pop();
	}
	/**
	 * Handles the dollar sign operator in Haskell.  Surrounds the items by an open parenthesis.
	 */
	@Override public void enterDollarSignTerm(HaskellParser.DollarSignTermContext ctx) { 
		fileContents.append("(");
	}
	/**
	 * Handles the dollar sign operator in Haskell.  Surrounds the items by an close parenthesis.
	 */
	@Override public void exitDollarSignTerm(HaskellParser.DollarSignTermContext ctx) { 
		fileContents.append(")");
	}	
	/**
	 * Whenever a Haskell function that needs to be converted to a Scala method is found, this pushes that method
	 * onto the function name stack. 
	 */
	@Override public void enterHaskellFunctionToScalaMethodName(HaskellParser.HaskellFunctionToScalaMethodNameContext ctx) { 
		haskellFunctionToScalaMethodName.push(ctx.getText());
	}
	/**
	 * Called when converting a Haskell function (followed by a dollar sign) to a Scala object method. Currently a no-op.
	 */
	@Override public void enterFunctionToMethodDollarSign(HaskellParser.FunctionToMethodDollarSignContext ctx) { }
	/**
	 * Called when converting a Haskell function (followed by a dollar sign) to a Scala object method. Currently a no-op.
	 */
	@Override public void exitFunctionToMethodDollarSign(HaskellParser.FunctionToMethodDollarSignContext ctx) { }
	/**
	 * Called when converting a Haskell function (surrounded in a parenthesis) to a Scala object method. Currently a no-op.
	 */
	@Override public void enterFunctionToMethodParen(HaskellParser.FunctionToMethodParenContext ctx) { }
	/**
	 * Called when converting a Haskell function (surrounded in a parenthesis) to a Scala object method. Currently a no-op. 
	 */
	@Override public void exitFunctionToMethodParen(HaskellParser.FunctionToMethodParenContext ctx) { }
	/**
	 * To simplify support in Scala, we need to surrunound in parentheses.
	 */
	@Override public void enterFunctionToMethodTerm(HaskellParser.FunctionToMethodTermContext ctx) { 
		fileContents.append("(");
	}
	/**
	 * When just a simple term, need to surround in parenthesis.
	 */
	@Override public void exitFunctionToMethodTerm(HaskellParser.FunctionToMethodTermContext ctx) { 
		fileContents.append(")");
	}
	/**
	 * Some functions in Haskell are converted to methods in Scala.  This is called at the beginning of that.
	 */
	@Override public void enterFunctionToMethod(HaskellParser.FunctionToMethodContext ctx) { }
	/**
	 * Called at the end of function to method conversion.  Converts the Haskell function
	 * name to scala.  Pops the function name off the stack.
	 */
	@Override public void exitFunctionToMethod(HaskellParser.FunctionToMethodContext ctx) { 
		String haskellFuncName = haskellFunctionToScalaMethodName.pop();
		fileContents.append(".").append(convertHaskellFunctionToScalaMethod(haskellFuncName)).append("()");
	}
    
	
	
	
	
    
    /************************************************************************************
    *                    Methods Related to the Main Method Only                        *
    ************************************************************************************/
    /**
     * Starts a main function.  Currently a no-op.
     */
    @Override public void enterMainFunction(HaskellParser.MainFunctionContext ctx) { }
    /**
     * Defines the main function prototype
     */
    @Override public void enterMainPrototype(HaskellParser.MainPrototypeContext ctx) { 
        fileContents.append("main(args : Array[String]){\n");
        incrementIndentLevel(false);
    }
    /**
     * Opens a main function statement. This currently just handles indenting the statement.
     */
    @Override public void enterMainStatement(HaskellParser.MainStatementContext ctx) { 
        printIndent();
    }
    /**
     * Closes a main function statement. This currently just handles indenting the statement.
     */
    @Override public void exitMainStatement(HaskellParser.MainStatementContext ctx) { 
        fileContents.append("\n");
    }
    /**
     * Used to convert a haskell Function name to a Scala function name.
     */
    @Override public void enterHaskellFunctionName(HaskellParser.HaskellFunctionNameContext ctx) { 
        fileContents.append(" ").append(convertHaskellFunctionNameToScala(ctx.getText()));
    }
    /**
     * Handle a LEFT parenthesis in the main method.  Just prints "("
     */
    @Override public void enterParenMainWord(HaskellParser.ParenMainWordContext ctx) { 
        fileContents.append("(");
    }
    /**
     * Handle a RIGHT parenthesis in the main method.  Just prints ")"
     */
    @Override public void exitParenMainWord(HaskellParser.ParenMainWordContext ctx) { 
        decrementIndentLevel(true);
        fileContents.append(")");
    }
    /**
     * Handle a LEFT parenthesis in the main method.  Just prints "("
     */
    @Override public void enterGeneralMainWord(HaskellParser.GeneralMainWordContext ctx) { 
        fileContents.append(" ").append(ctx.getText());
    }
    
    
    
    
    
    
    /**************************************************************************************
     *   Generic Helper Functions.  These are not relays to the Grammar's Base Listener   *
     *************************************************************************************/
    
    /**
     * Outputs the converted Haskell code to Scala.
     * 
     * @return Haskell code as a String of Scala Code
     */
    @Override public String toString(){
        return fileContents.toString();
    }
    /**
     * Creates a standardized, highly customized input parameter name.  This is needed because 
     * by default, Haskell does not have input parameter names.
     * 
     * @param paramNumb       
     * @return              String representing the specified input parameter
     */
    private String getInputParameterName(int paramNumb){ return "___" + paramNumb + "___"; }
    /**
     * Uses the standard getInputParameterName function.  Rather than using a specific parameter
     * number, this one uses the next parameter's ID number.
     * 
     * @return  Next Parameter's Name.
     */
    private String getInputParameterName(){ return getInputParameterName(nextParamNumber); }
    /*
     * At the beginning of a function, reset the parameter number.
     */
    private void incrementParameterId(){ nextParamNumber++; };
    /*
     * At the beginning of a function, reset the parameter number.
     */
    private void resetNextParamNumber(){ nextParamNumber = BASE_PARAM_NUMBER; };
    /**
     * Checks whether handling the first parameter.
     * 
     * @return "true" if the current parameter is the first and "false" otherwise.
     */
    private boolean isFirstParameter(){ return nextParamNumber == BASE_PARAM_NUMBER; }
    /**
     * Sets the indent level to the default.
     */
    private void resetIndentLevel(){indentLevel = BASE_PARAM_NUMBER;}  
    /**
     * Increment the indent by one level.
     * 
     * @param printIndent  If true, an indent at the specified indent level is added.
     */
    private void incrementIndentLevel(boolean printIndent){
        indentLevel++;
        if(printIndent) printIndent();
    }
    /**
     * Decrements the indent by one level.
     * 
     * @param printIndent  If true, an indent at the specified indent level is added.
     */
    private void decrementIndentLevel(boolean printIndent){
        indentLevel--;
        if(printIndent) printIndent();
    }
    /**
     * Adds an indent based off the specified indent level to the scala file contents.
     */
    private void printIndent(){
        for(int i = 0; i < indentLevel; i++)
            fileContents.append(TAB_STRING);
    }
    /**
     * 
     * @param haskellType
     * @return
     */
    private String convertHaskellTypeNameToScala(String haskellType){
        // Handle the support Haskell types.
        switch(haskellType){
            case "Int": return "Int";
            case "[Int]": return "List[Int]";
            case "Bool": return "Boolean";
            case "[Char]": return "String";
            case "Char": return "Char";
            
        }
        // Handle the base case.
        return baseErrorMessage + "TYPE NAME.";
    }
    /**
     * Converts Haskell function names to their Scala equivalents.
     * 
     * @param functionName  A supported Haskell function name.
     * @return              Equivalent Scala function name.
     */
    public String convertHaskellFunctionNameToScala(String functionName){
        switch(functionName){
            case "putStrLn": return "println";
            case "putStr": return "print";
        }
        return baseErrorMessage + "FUNCTION NAME.";
    }
    
    /**
     * Since Haskell does not have objects in an object oriented way, all operations are done
     * as functions.  In contrast, Scala supports objects so some of operations that in Haskell
     * are functions are methods in Scala.  An example of this is "show" in Haskell which
     * translates to "toString()" in Scala.
     * 
     * @param functionName Function name in Haskell
     * 
     * @return   Matching method name in Scala.
     */
    public String convertHaskellFunctionToScalaMethod(String functionName){
    	switch(functionName){
    	case "show": return "toString";
    	}
    	return baseErrorMessage + "FUNCTION NAME.";
    }
    
    
    
}
