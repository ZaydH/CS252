\documentclass{article}

\usepackage{fullpage}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
%\usepackagen{url}
\usepackage{float}
\usepackage{paralist}

\floatstyle{boxed}
\restylefloat{figure}



\newcommand{\rel}[1]{ \mbox{\sc [#1]} }

\title{Homework 2: Operational Semantics for WHILE}

\author{
  CS 252: Advanced Programming Languages \\
  Prof. Thomas H. Austin \\
  San Jos\'{e} State University \\
  }
\date{}

\begin{document}
\maketitle

\section{Introduction}

For this assignment,
you will implement the semantics for a small imperative language, named WHILE.

% Commands for formatting figure
\newcommand{\mydefhead}[2]{\multicolumn{2}{l}{{#1}}&\mbox{\emph{#2}}\\}
\newcommand{\mydefcase}[2]{\qquad\qquad& #1 &\mbox{#2}\\}

% Commands for language format
\newcommand{\assign}[2]{#1~{:=}~#2}
\newcommand{\ife}[3]{\mbox{\tt if}~{#1}~\mbox{\tt then}~{#2}~\mbox{\tt else}~{#3}}
\newcommand{\whilee}[2]{\mbox{\tt while}~(#1)~#2}
\newcommand{\note}[1]{\mbox{\tt not}~#1}
\newcommand{\ande}[2]{\mbox{\tt and}~(#1)~#2}
\newcommand{\ore}[2]{\mbox{\tt or}~(#1)~#2}
\newcommand{\true}{\mbox{\tt true}}
\newcommand{\false}{\mbox{\tt false}}

\begin{figure}\label{fig:lang}
\caption{The WHILE language}
\[
\begin{array}{llr}
  \mydefhead{e ::=\qquad\qquad\qquad\qquad}{Expressions}
  \mydefcase{x}{variables/addresses}
  \mydefcase{v}{values}
  \mydefcase{\assign x e}{assignment}
  \mydefcase{e; e}{sequential expressions}
  \mydefcase{e ~op~ e}{binary operations}
  \mydefcase{\ife e e e}{conditional expressions}
  \mydefcase{\whilee e e}{while expressions}
  \mydefcase{\note e}{not expressions}
  \mydefcase{\ande e e}{and expressions}
  \mydefcase{\ore e e}{or expressions}
  \\
  \mydefhead{v ::=\qquad\qquad\qquad\qquad}{Values}
  \mydefcase{i}{integer values}
  \mydefcase{b}{boolean values}
  \\
  op ::= & + ~|~ - ~|~ * ~|~ / ~|~ > ~|~ >= ~|~ < ~|~ <=  & \mbox{\emph{Binary operators}} \\
\end{array}
\]
\end{figure}
($e_1;e_2$)



%---------
\section{Small-step semantics}

\newcommand{\ssrule}[3]{
  \rel{#1} &
  \frac{\strut\begin{array}{@{}c@{}} #2 \end{array}}
       {\strut\begin{array}{@{}c@{}} #3 \end{array}}
   \\~\\
}
\newcommand{\sstep}[4]{{#1},{#2} \rightarrow {#3},{#4}}
\newcommand{\sstepraw}[4]{{#1},{#2} \rightarrow {#3},{#4}}


Most of these rules are fairly straightforward, but there are a couple of points
to note with the $\rel{ss-while}$ rule.


\begin{figure}[H]\label{fig:smallstep}
\caption{Small-step semantics for WHILE}
{\bf Runtime Syntax:}
\[
\begin{array}{rclcl}
  \sigma & \in & {Store} \quad  & = & \quad {variable} ~\rightarrow ~v \\
  \\
\end{array}
\]
{\bf Evaluation Rules:~~~ \fbox{$\sstepraw{e}{\sigma}{e'}{\sigma'}$}} \\
\[
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-var}{
  x \in domain(\sigma) \qquad \sigma(x)=v
}{
  \sstep{x}{\sigma}{v}{\sigma}
}
\ssrule{ss-assign}{
}{
  \sstep{\assign{x}{v}}{\sigma}{v}{\sigma[x:=v]}
}
\ssrule{ss-op}{
  v = v_1 ~op~ v_2
}{
  \sstep{v_1~op~v_2}{\sigma}{v}{\sigma}
}
\ssrule{ss-seq}{
}{
  \sstep{v;e}{\sigma}{e}{\sigma}
}
\ssrule{ss-iftrue}{
}{
  \sstep{\ife{\true}{e_1}{e_2}}{\sigma}{e_1}{\sigma}
}
\ssrule{ss-iffalse}{
}{
  \sstep{\ife{\false}{e_1}{e_2}}{\sigma}{e_2}{\sigma}
}
\ssrule{ss-while}{
}{
  \sstep{\whilee{e_1}{e_2}}{\sigma}{\ife{e_1}{e_2;\whilee{e_1}{e_2}}{\false}}{\sigma}
}
\end{array}
\]
\end{figure}

\begin{figure}[H]\label{fig:varRules}
\caption{Variable Small-Step Semantics Evaluation Order Rules}
{\bf Variable Evaluation Rules:} \\
\[
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-var}{
  x \in domain(\sigma) \qquad \sigma(x)=v
}{
  \sstep{x}{\sigma}{v}{\sigma}
}
\end{array}
\]
\end{figure}

\begin{figure}[H]\label{fig:assignRules}
\caption{Set/Assignment Small-Step Semantics Evaluation Order Rules}
{\bf Set/Assignment Evaluation Rules:} \\
\[
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-assignContext}{
  \sstep{e}{\sigma}{e'}{\sigma'}
}{
  \sstep{\assign{x}{e}}{\sigma}{\assign{x}{e'}}{\sigma'}
}
\ssrule{ss-assignReduction}{
}{
  \sstep{\assign{x}{v}}{\sigma}{v}{\sigma[x:=v]}
}
\end{array}
\]
\end{figure}

\begin{figure}[H]\label{fig:seqRules}
\caption{Sequence ({\tt ;}) Evaluation Order Rules}
{\bf Sequence ({\tt ;}) Evaluation Rules:} \\
\[
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-seqContext}{
  \sstep{e_1}{\sigma}{e_1'}{\sigma'}
}{
  \sstep{e_1 ; e_2}{\sigma}{e_1' ; e_2}{\sigma'}
}
\ssrule{ss-seqReduction}{
}{
  \sstep{v ; e}{\sigma}{e}{\sigma'}
}
\end{array}
\]
\end{figure}

\begin{figure}[H]\label{fig:condRules}
\caption{Conditional ({\tt if}) Small-Step Semantics Evaluation Order Rules}
{\bf Conditional Statement ({\tt if}) Evaluation Rules:} \\
\[
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-ifContext}{
  \sstep{e_1}{\sigma}{e_1'}{\sigma'}
}{
  \sstep{\ife{e_1}{e_2}{e_3}}{\sigma}{\ife{e_1'}{e_2}{e_3}}{\sigma'}
}
\ssrule{ss-ifTrueReduction}{
}{
  \sstep{\ife{\true}{e_1}{e_2}}{\sigma}{e_1}{\sigma}
}
\ssrule{ss-ifFalseReduction}{
}{
  \sstep{\ife{\false}{e_1}{e_2}}{\sigma}{e_2}{\sigma}
}
\end{array}
\]
\end{figure}

\begin{figure}[H]\label{fig:whileRules}
\caption{{\tt while} Small-Step Semantics Evaluation Order Rules}
{\bf {\tt while} Evaluation Rules:} \\
\[
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-while}{
}{
  \sstep{\whilee{e_1}{e_2}}{\sigma}{\ife{e_1}{e_2;\whilee{e_1}{e_2}}{\false}}{\sigma}
}
\end{array}
\]
\end{figure}

%---------
\section{Boolean Expressions Small-Step Semantics}

In this section, I add three new expression types to the WHILE language namely: {\tt not}, {\tt and}, and {\tt or}.  The evaluation order rules for each are below.\\

\bf Do I need the parentheses is in the "{\tt and}" and "{\tt or}" statements?  Is an infix style more typically used?

\begin{figure}[H]\label{fig:notRules}
\caption{{\tt not} Small-Step Semantics Evaluation Order Rules}
{\bf {\tt not} Evaluation Rules:} \\
\[
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-notContext}{
  \sstep{e}{\sigma}{e'}{\sigma'}
}{
  \sstep{\note{e}}{\sigma}{\note{e'}}{\sigma'}
}
\end{array}
\]
{\bf Not sure if I need this.  If I do, then why?  Why is this not like the 
"{\tt op}" case:} \\
\[
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-notReduction}{
}{
  \sstep{\note{v}}{\sigma}{\ife{v}{\false}{\true}}{\sigma}
}
\end{array}
\]
{\bf I believe the above rule makes these unnecessary.  Would most define as above or like below?} \\
\[
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-notTrue}{
}{
  \sstep{\note{\true}}{\sigma}{\false}{\sigma}
}
\ssrule{ss-notFalse}{
}{
  \sstep{\note{\false}}{\sigma}{\true}{\sigma}
}
\end{array}
\]
\end{figure}

\begin{figure}[H]\label{fig:andRules}
\caption{{\tt and} Small-Step Semantics Evaluation Order Rules}
{\bf {\tt and} Evaluation Rules:} \\
\[
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-andContext}{
  \sstep{e_1}{\sigma}{e_1'}{\sigma'}
}{
  \sstep{\ande{e_1}{e_2}}{\sigma}{\ande{e_1'}{e_2}}{\sigma'}
}
\ssrule{ss-andReduction}{
}{
  \sstep{\ande{v}{e}}{\sigma}{\ife{v}{e}{\false}}{\sigma}
}
\end{array}
\]
{\bf Using the above, I think I do not need these:} \\
\[
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-andContext2}{
  \sstep{e}{\sigma}{e'}{\sigma'}
}{
  \sstep{\ande{v}{e}}{\sigma}{\ande{v}{e'}}{\sigma'}
}
\ssrule{ss-andAllTrue}{
}{
  \sstep{\ande{\true}{\true}}{\sigma}{\true}{\sigma}
}
\ssrule{ss-andFalse1}{
}{
  \sstep{\ande{\false}{v}}{\sigma}{\false}{\sigma}
}
\ssrule{ss-andFalse2}{
}{
  \sstep{\ande{v}{\false}}{\sigma}{\false}{\sigma}
}
\end{array}
\]
\end{figure}

\begin{figure}[H]\label{fig:orRules}
\caption{{\tt or} Evaluation Order Rule}
{\bf {\tt or} Evaluation Rules: (Is defining "temporary variables" as I did allowed in small step semantics?)} \\
\[
\begin{array}{r@{\qquad\qquad}l}
\ssrule{ss-orReduction}{
  e_1'=\note{e_1} \qquad e_2'=\note{e_2} \qquad e_3=\ande{e_1'}{e_2'}
}{
  \sstep{\ore{e_1}{e_2}}{\sigma}{\note{e_3}}{\sigma}
}
\end{array}
\]
\end{figure}

\end{document}

